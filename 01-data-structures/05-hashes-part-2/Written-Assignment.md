***************************************************************************

Timothys-MBP:open_addressing tim$ rspec open_addressing_spec.rb

***      ****      ***
Array size = 12
Items in array = 6
***      ****      ***
The array position 2 has key of Number Five and value of: Number Five
The array position 3 has key of Number Two and value of: Number Two
The array position 4 has key of Number Four and value of: Number Four
The array position 5 has key of Number Six and value of: Number Six
The array position 6 has key of Number One and value of: Number One
The array position 11 has key of Number Three and value of: Number Three
***      ****      ***
........

Finished in 0.00343 seconds (files took 0.11501 seconds to load)
8 examples, 0 failures

Timothys-MBP:open_addressing tim$

***************************************************************************

Timothys-MBP:separate_chaining tim$ rspec separate_chaining_spec.rb

***      ****      ***
Array size = 12
Items in array = 6
Load factor = 0.5
***      ****      ***
The array position 2 has key of Star Wars: The Empire Strikes Back and value of: Number Five
The array position 3 has key of Star Wars: Attack of the Clones and value of: Number Two
The array position 3 has key of Star Wars: Return of the Jedi and value of: Number Six
The array position 4 has key of Star Wars: A New Hope and value of: Number Four
The array position 6 has key of Star Wars: The Phantom Menace and value of: Number One
The array position 11 has key of Star Wars: Revenge of the Sith and value of: Number Three
***      ****      ***
.......

Finished in 0.00439 seconds (files took 0.11805 seconds to load)
7 examples, 0 failures

Timothys-MBP:separate_chaining tim$

***************************************************************************

1. *Describe three collision resolution strategies not mentioned here.*
  1. Double hashing: There's an offset number in addition to the has value. If there's a collision at the hashed value, the next position will depend on the offset number that's based on the key value. This means the value will be different for different keys.

  2. Random hashing: hash key is generated by a random number generator who's output is based not on the time of the entry but on the key being entered.

  3. Hopscotch Hashing: each bucket has a "neighborhood" (buckets close in number and consecutive). The primary bucket is in the same memory location as all the buckets in the neighborhood. That means look-ups for items in 1 neighborhood will be in contiguous memory locations. This is cache friendly.

2. *Create your own collision resolution strategy and describe how it works.*
Find the length of the key and multiply it by the sum (or numerical value if not a string) of the key.
Example:
key = "Robert Nesta"
keySum = key.sum
keyLength = key.length

keySum = 1161
keyLength = 12
hash = 13932
